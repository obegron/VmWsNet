<!DOCTYPE html>
<html>

<head>
  <title>rootlessRelay admin</title>
  <style>
    :root {
      --ctp-rosewater: #f5e0dc;
      --ctp-flamingo: #f2cdcd;
      --ctp-pink: #f5c2e7;
      --ctp-mauve: #cba6f7;
      --ctp-red: #f38ba8;
      --ctp-maroon: #eba0ac;
      --ctp-peach: #fab387;
      --ctp-yellow: #f9e2af;
      --ctp-green: #a6e3a1;
      --ctp-teal: #94e2d5;
      --ctp-sky: #89dceb;
      --ctp-sapphire: #74c7ec;
      --ctp-blue: #89b4fa;
      --ctp-lavender: #b4befe;
      --ctp-text: #cdd6f4;
      --ctp-subtext1: #bac2de;
      --ctp-subtext0: #a6adc8;
      --ctp-overlay2: #9399b2;
      --ctp-overlay1: #7f849c;
      --ctp-overlay0: #6c7086;
      --ctp-surface2: #585b70;
      --ctp-surface1: #45475a;
      --ctp-surface0: #313244;
      --ctp-base: #1e1e2e;
      --ctp-mantle: #181825;
      --ctp-crust: #11111b;
    }

    body {
      font-family: -apple-system,BlinkMacSystemFont,avenir next,avenir,segoe ui,helvetica neue,Cantarell,Ubuntu,roboto,noto,helvetica,arial,sans-serif;
      background-color: var(--ctp-base);
      color: var(--ctp-text);
      margin: 50px;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      background-color: var(--ctp-mantle);
      color: var(--ctp-text);
    }

    th,
    td {
      border: 1px solid var(--ctp-surface1);
      padding: 8px;
      text-align: left;
    }

    th {
      background-color: var(--ctp-surface0);
      color: var(--ctp-text);
    }

    form {
      margin-bottom: 20px;
      background-color: var(--ctp-mantle);
      padding: 15px;
      border-radius: 8px;
    }

    .form-group {
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
    }

    .form-group label {
      margin-bottom: 5px;
      color: var(--ctp-text);
    }

    .form-group input[type="text"],
    .form-group select {
      width: 200px;
      padding: 8px;
      border: 1px solid var(--ctp-surface1);
      border-radius: 4px;
      background-color: var(--ctp-crust);
      color: var(--ctp-text);
    }

    .optional-text {
      font-size: 0.8em;
      color: var(--ctp-subtext0);
      margin-top: 2px;
    }

    .toaster-notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--ctp-green);
      color: var(--ctp-crust);
      padding: 10px 20px;
      border-radius: 5px;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      z-index: 1000;
    }

    .toaster-notification.show {
      opacity: 1;
    }

    h1 {
      color: var(--ctp-rosewater);
    }

    h2 {
      color: var(--ctp-lavender);
    }

    a {
      color: var(--ctp-blue);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    code {
      background-color: var(--ctp-surface0);
      color: var(--ctp-text);
      padding: 2px 4px;
      border-radius: 4px;
    }

    .common-buttons button,
    button[type="submit"],
    .catppuccin-button {
      background-color: var(--ctp-blue);
      color: var(--ctp-crust);
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      margin-right: 10px; /* Space between buttons */
    }

    .common-buttons button:hover,
    button[type="submit"]:hover,
    .catppuccin-button:hover {
      background-color: var(--ctp-sapphire);
    }

    button.delete-button {
      background-color: var(--ctp-red);
    }

    button.delete-button:hover {
      background-color: var(--ctp-maroon);
    }

    .catppuccin-input {
      padding: 8px;
      border: 1px solid var(--ctp-surface1);
      border-radius: 4px;
      background-color: var(--ctp-crust);
      color: var(--ctp-text);
    }

    .copy-button {
      margin-bottom: 5px; /* Add some space below each copy button */
    }

    /* Style for radio buttons and checkboxes */
    input[type="radio"],
    input[type="checkbox"] {
      /* Hide default radio/checkbox */
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      width: 16px;
      height: 16px;
      border: 2px solid var(--ctp-surface1);
      border-radius: 3px;
      margin-right: 5px;
      position: relative;
      cursor: pointer;
      background-color: var(--ctp-crust);
    }

    input[type="radio"] {
      border-radius: 50%; /* Make radio buttons circular */
    }

    input[type="radio"]:checked,
    input[type="checkbox"]:checked {
      border-color: var(--ctp-blue);
      background-color: var(--ctp-blue);
    }

    input[type="radio"]:checked::before {
      content: '';
      display: block;
      width: 8px;
      height: 8px;
      background-color: var(--ctp-crust);
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    input[type="checkbox"]:checked::before {
      content: '\2713'; /* Checkmark character */
      display: block;
      color: var(--ctp-crust);
      font-size: 12px;
      line-height: 1;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    /* Adjust spacing for common buttons */
    .common-buttons {
      display: flex;
      gap: 10px; /* Space between buttons */
      margin-top: 10px;
      margin-bottom: 10px;
    }

    .common-buttons button:hover,
    button[type="submit"]:hover {
      background-color: var(--ctp-sapphire);
    }

    button.delete-button {
      background-color: var(--ctp-red);
    }

    button.delete-button:hover {
      background-color: var(--ctp-maroon);
    }
  </style>
</head>

<body>
  <h1>rootlessRelay Admin</h1>
  <h2>Connected Clients</h2>
  <table id="sessions">
    <thead>
      <tr>
        <th>Session ID</th>
        <th>Client IP</th>
        <th>VM IP</th>
        <th>VM MAC</th>
        <th>Bytes Sent</th>
        <th>Bytes Received</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>

  <h2>Reverse Proxy Rules</h2>
  <form id="add-rule-form">
    <div>
      <label><input type="radio" name="proxy_type" value="http" checked> HTTP Proxy</label>
      <label><input type="radio" name="proxy_type" value="port"> Port Forward</label>
    </div>
    <div id="http-fields">
      <div class="form-group">
        <label for="vm">VM:</label>
        <select id="vm"></select>
      </div>
      <div class="form-group">
        <label for="port">VM Port:</label>
        <input type="text" id="port" placeholder="e.g., 80">
      </div>
      <div class="form-group">
        <label for="path">Path:</label>
        <input type="text" id="path" placeholder="e.g., /">
      </div>
      <div class="form-group">
        <label for="targetPath">Target Path:</label>
        <input type="text" id="targetPath" placeholder="e.g., /app">
        <span class="optional-text">optional</span>
      </div>
      <div class="form-group">
        <label for="vhost">VHost:</label>
        <input type="text" id="vhost" placeholder="e.g., domain.com">
        <span class="optional-text">optional</span>
      </div>
    </div>
    <div id="port-fields" style="display: none;">
      <div class="form-group">
        <label style="visibility: hidden;">Protocol(s):</label>
        <div>
          <label><input type="checkbox" name="protocol" value="tcp" checked> TCP</label>
          <label><input type="checkbox" name="protocol" value="udp"> UDP</label>
        </div>
      </div>
      <div class="form-group">
        <label for="host_port">Local Port:</label>
        <input type="text" id="host_port" placeholder="e.g., 4445">
      </div>
      <div class="form-group">
        <label for="vm-port">VM:</label>
        <select id="vm-port"></select>
      </div>
      <div class="form-group">
        <label for="port-port">Remote Port:</label>
        <input type="text" id="port-port" placeholder="e.g., 80">
      </div>
      <div class="common-buttons">
        <button type="button" onclick="addSshPortForward()">Add SSH (2222 -> VM:22)</button>
        <button type="button" onclick="addHttpPortForward()">Add HTTP (8888 -> VM:80)</button>
      </div>
    </div>
    <button type="submit">Add Rule</button>
  </form>
  <table id="rules">
    <thead>
      <tr>
        <th>Type</th>
        <th>VHost</th>
        <th>Path</th>
        <th>Destination</th>
        <th>Target Path</th>
        <th>Test</th>
        <th>Action&nbsp;</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>

  <div id="toaster-notification" class="toaster-notification"></div>

  <script>
    async function fetchSessions() {
      const response = await fetch('/api/sessions');
      const sessions = await response.json();
      const tbody = document.querySelector('#sessions tbody');
      const vmDropdownHttp = document.getElementById('vm');
      const vmDropdownPort = document.getElementById('vm-port');
      const selectedVmHttp = vmDropdownHttp.value;
      const selectedVmPort = vmDropdownPort.value;

      // Store current nickname input values to restore later
      const currentNicknameInputs = new Map();
      tbody.querySelectorAll('input[id^="new-nickname-input-"]').forEach(input => {
        currentNicknameInputs.set(input.id, input.value);
      });

      tbody.innerHTML = ''; // Clear and re-render the table structure
      vmDropdownHttp.innerHTML = '<option value="">Select VM</option>';
      vmDropdownPort.innerHTML = '<option value="">Select VM</option>';

      for (const session of sessions) {
        if (session.vmIP) { // Only add VMs with assigned IPs
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>
              <span id="display-nickname-${session.sessionId}" onclick="editNickname('${session.sessionId}', '${session.nickname || ''}')" style="cursor: pointer;">${session.nickname || session.sessionId}</span>
            </td>
            <td>${session.clientIP}</td>
            <td>${session.vmIP}</td>
            <td>${session.vmMAC}</td>
            <td>${session.bytesSent}</td>
            <td>${session.bytesReceived}</td>
          `;
          tbody.appendChild(row);

          // Restore input value if it was being typed in
          const inputId = `new-nickname-input-${session.sessionId}`;
          if (currentNicknameInputs.has(inputId)) {
            document.getElementById(inputId).value = currentNicknameInputs.get(inputId);
          }

          const optionHttp = document.createElement('option');
          optionHttp.value = session.vmIP;
          optionHttp.textContent = `${session.nickname || session.vmIP}`;
          vmDropdownHttp.appendChild(optionHttp);

          const optionPort = document.createElement('option');
          optionPort.value = session.vmIP;
          optionPort.textContent = `${session.nickname || session.vmIP}`;
          vmDropdownPort.appendChild(optionPort);
        }
      }
      vmDropdownHttp.value = selectedVmHttp;
      vmDropdownPort.value = selectedVmPort;
    }
    fetchSessions();
    setInterval(fetchSessions, 5000);

    const typeRadios = document.querySelectorAll('input[name="proxy_type"]');
    const httpFields = document.getElementById('http-fields');
    const portFields = document.getElementById('port-fields');

    typeRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        if (document.querySelector('input[name="proxy_type"]:checked').value === 'port') {
          httpFields.style.display = 'none';
          portFields.style.display = 'block';
        } else {
          httpFields.style.display = 'block';
          portFields.style.display = 'none';
        }
      });
    });

    document.getElementById('add-rule-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const proxyType = document.querySelector('input[name="proxy_type"]:checked').value;
      let rule;

      if (proxyType === 'port') {
        const protocols = Array.from(document.querySelectorAll('input[name="protocol"]:checked')).map(cb => cb.value);
        if (protocols.length === 0) {
          alert('Please select at least one protocol (TCP or UDP).');
          return;
        }
        const hostPort = parseInt(document.getElementById('host_port').value);

        // Fetch existing rules to check for duplicates
        const existingRulesResponse = await fetch('/api/rules');
        const existingRules = await existingRulesResponse.json();

        const isDuplicatePort = existingRules.some(rule =>
          rule.type === 'port' && rule.host_port === hostPort
        );

        if (isDuplicatePort) {
          alert(`A port forward rule already exists for local port ${hostPort}.`);
          return;
        }

        rule = {
          type: 'port',
          protocols: protocols, // e.g., ['tcp'], ['udp'], or ['tcp', 'udp']
          vm: document.getElementById('vm-port').value,
          port: parseInt(document.getElementById('port-port').value),
          host_port: hostPort,
        };
      } else { // http
        rule = {
          type: 'http',
          vm: document.getElementById('vm').value,
          port: parseInt(document.getElementById('port').value),
          vhost: document.getElementById('vhost').value,
          path: document.getElementById('path').value,
          targetPath: document.getElementById('targetPath').value,
        };
      }

      await fetch('/api/rules', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(rule),
      });
      loadRules();
    });

    function showToaster(message, isError = false) {
      const toaster = document.getElementById('toaster-notification');
      toaster.textContent = message;
      toaster.style.backgroundColor = isError ? 'var(--ctp-red)' : 'var(--ctp-green)'; // Red for error, green for success
      toaster.style.color = 'var(--ctp-crust)';
      toaster.classList.add('show');
      setTimeout(() => {
        toaster.classList.remove('show');
      }, 3000);
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showToaster('Copied to clipboard!');
      }, (err) => {
        showToaster('Failed to copy: ' + err, true);
      });
    }

    async function loadRules() {
      const response = await fetch('/api/rules');
      const rules = await response.json();
      const tbody = document.querySelector('#rules tbody');
      tbody.innerHTML = '';
      for (const rule of rules) {
        const row = document.createElement('tr');
        let vhost, path, targetPath, testInfo, typeDisplay;

        if (rule.type === 'port') {
          typeDisplay = 'Port Forward';
          vhost = rule.host_port;
          path = rule.protocols.join(', ').toUpperCase();
          targetPath = '';
          const tcpCommand = `telnet localhost ${rule.host_port}`;
          const udpCommand = `echo "test" | nc -u -w1 localhost ${rule.host_port}`;
          let commands = [];
          if (rule.protocols.includes('tcp')) {
            commands.push(`<button onclick="copyToClipboard('${tcpCommand}')" class="catppuccin-button copy-button">Copy</button> <code>${tcpCommand}</code>`);
          }
          if (rule.protocols.includes('udp')) {
            commands.push(`<button onclick="copyToClipboard('${udpCommand}')" class="catppuccin-button copy-button">Copy</button> <code>${udpCommand}</code>`);
          }
          testInfo = commands.join('<br>');
        } else { // http
          typeDisplay = 'HTTP';
          vhost = rule.vhost || '';
          path = rule.path || '';
          targetPath = rule.targetPath || '';
          const proxyUrl = `http://localhost:8080${path}`;
          const link = rule.vhost ? `http://${rule.vhost}:8080${path}` : proxyUrl;
          const curlCommand = rule.vhost ? `curl -H "Host: ${rule.vhost}" ${proxyUrl}` : `curl ${proxyUrl}`;
          testInfo = `<button onclick="copyToClipboard('${curlCommand}')" class="catppuccin-button">Copy</button> <code>${curlCommand}</code><br><a href="${link}" target="_blank">${link}</a>`;
        }

        row.innerHTML = `
          <td>${typeDisplay}</td>
          <td>${vhost}</td>
          <td>${path}</td>
          <td>${rule.vm}:${rule.port}</td>
          <td>${targetPath}</td>
          <td>${testInfo}</td>
          <td><button onclick="deleteRule('${rule.id}')" class="catppuccin-button delete-button">Delete</button></td>
        `;
        tbody.appendChild(row);
      }
    }

    async function deleteRule(id) {
      await fetch(`/api/rules/${id}`, {method: 'DELETE'});
      loadRules();
    }

    async function setNickname(sessionId, nickname) {
      if (nickname) { // Only send if nickname is not empty
        await fetch(`/api/sessions/${sessionId}/nickname`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({nickname}),
        });
      } else {
        // If nickname is empty, delete it
        await fetch(`/api/sessions/${sessionId}/nickname`, {
          method: 'DELETE',
        });
      }
      fetchSessions(); // Refresh sessions to show updated nickname
    }

    function editNickname(sessionId, currentNickname) {
      const displaySpan = document.getElementById(`display-nickname-${sessionId}`);
      const originalContent = displaySpan.innerHTML;

      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentNickname;
      input.className = 'catppuccin-input';
      input.style.width = 'auto'; // Adjust width as needed

      displaySpan.innerHTML = '';
      displaySpan.appendChild(input);
      input.focus();

      const handleSave = async () => {
        const newNickname = input.value.trim();
        await setNickname(sessionId, newNickname);
        displaySpan.innerHTML = originalContent; // Revert to original content temporarily
        fetchSessions(); // Refresh to show actual new nickname
      };

      input.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          handleSave();
        }
      });

      input.addEventListener('blur', () => {
        // If the input loses focus, save the nickname (or delete if empty)
        handleSave();
      });
    }

    async function addSshPortForward() {
      document.querySelector('input[name="proxy_type"][value="port"]').checked = true;
      document.getElementById('http-fields').style.display = 'none';
      document.getElementById('port-fields').style.display = 'block';

      document.getElementById('host_port').value = '2222';
      document.getElementById('port-port').value = '22';
      document.getElementById('vm-port').value = document.getElementById('vm-port').options[1] ? document.getElementById('vm-port').options[1].value : ''; // Select first available VM

      document.querySelector('input[name="protocol"][value="tcp"]').checked = true;
      document.querySelector('input[name="protocol"][value="udp"]').checked = true;

      document.getElementById('add-rule-form').dispatchEvent(new Event('submit'));
    }

    async function addHttpPortForward() {
      document.querySelector('input[name="proxy_type"][value="port"]').checked = true;
      document.getElementById('http-fields').style.display = 'none';
      document.getElementById('port-fields').style.display = 'block';

      document.getElementById('host_port').value = '8888';
      document.getElementById('port-port').value = '80';
      document.getElementById('vm-port').value = document.getElementById('vm-port').options[1] ? document.getElementById('vm-port').options[1].value : ''; // Select first available VM

      document.querySelector('input[name="protocol"][value="tcp"]').checked = true;
      document.querySelector('input[name="protocol"][value="udp"]').checked = false; // Only TCP for HTTP

      document.getElementById('add-rule-form').dispatchEvent(new Event('submit'));
    }

    loadRules();
  </script>
</body>

</html>
