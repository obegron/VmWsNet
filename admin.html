<!DOCTYPE html>
<html>

<head>
  <title>rootlessRelay admin</title>
  <style>
    body {
      font-family: sans-serif;
    }

    table {
      border-collapse: collapse;
      width: 100%;
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }

    th {
      background-color: #f2f2f2;
    }

    form {
      margin-bottom: 20px;
    }

    .form-group {
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
    }

    .form-group label {
      margin-bottom: 5px;
    }

    .form-group input[type="text"],
    .form-group select {
      width: 200px;
    }

    .optional-text {
      font-size: 0.8em;
      color: #666;
      margin-top: 2px;
    }

    .toaster-notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      z-index: 1000;
    }

    .toaster-notification.show {
      opacity: 1;
    }

    .common-buttons button {
      margin-right: 10px;
      /* Space between buttons */
    }
  </style>
</head>

<body>
  <h1>JSLinux Relay Admin</h1>
  <h2>Connected Clients</h2>
  <table id="sessions">
    <thead>
      <tr>
        <th>Session ID</th>
        <th>Client IP</th>
        <th>VM IP</th>
        <th>VM MAC</th>
        <th>Bytes Sent</th>
        <th>Bytes Received</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>

  <h2>Reverse Proxy Rules</h2>
  <form id="add-rule-form">
    <div>
      <label><input type="radio" name="proxy_type" value="http" checked> HTTP Proxy</label>
      <label><input type="radio" name="proxy_type" value="port"> Port Forward</label>
    </div>
    <div id="http-fields">
      <div class="form-group">
        <label for="vm">VM:</label>
        <select id="vm"></select>
      </div>
      <div class="form-group">
        <label for="port">VM Port:</label>
        <input type="text" id="port" placeholder="e.g., 80">
      </div>
      <div class="form-group">
        <label for="path">Path:</label>
        <input type="text" id="path" placeholder="e.g., /">
      </div>
      <div class="form-group">
        <label for="targetPath">Target Path:</label>
        <input type="text" id="targetPath" placeholder="e.g., /app">
        <span class="optional-text">optional</span>
      </div>
      <div class="form-group">
        <label for="vhost">VHost:</label>
        <input type="text" id="vhost" placeholder="e.g., domain.com">
        <span class="optional-text">optional</span>
      </div>
    </div>
    <div id="port-fields" style="display: none;">
      <div class="form-group">
        <label>Protocol(s):</label>
        <div>
          <label><input type="checkbox" name="protocol" value="tcp" checked> TCP</label>
          <label><input type="checkbox" name="protocol" value="udp"> UDP</label>
        </div>
      </div>
      <div class="form-group">
        <label for="host_port">Host Port:</label>
        <input type="text" id="host_port" placeholder="e.g., 4445">
      </div>
      <div class="form-group">
        <label for="vm-port">VM:</label>
        <select id="vm-port"></select>
      </div>
      <div class="form-group">
        <label for="port-port">VM Port:</label>
        <input type="text" id="port-port" placeholder="e.g., 80">
      </div>
      <div class="common-buttons">
        <button type="button" onclick="addSshPortForward()">Add SSH (2222 -> VM:22)</button>
        <button type="button" onclick="addHttpPortForward()">Add HTTP (8888 -> VM:80)</button>
      </div>
    </div>
    <button type="submit">Add Rule</button>
  </form>
  <table id="rules">
    <thead>
      <tr>
        <th>Type</th>
        <th>VHost</th>
        <th>Path</th>
        <th>Destination</th>
        <th>Target Path</th>
        <th>Test</th>
        <th>Action&nbsp;</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>

  <div id="toaster-notification" class="toaster-notification"></div>

  <script>
    async function fetchSessions() {
      const response = await fetch('/api/sessions');
      const sessions = await response.json();
      const tbody = document.querySelector('#sessions tbody');
      const vmDropdownHttp = document.getElementById('vm');
      const vmDropdownPort = document.getElementById('vm-port');
      const selectedVmHttp = vmDropdownHttp.value;
      const selectedVmPort = vmDropdownPort.value;

      // Store current nickname input values to restore later
      const currentNicknameInputs = new Map();
      tbody.querySelectorAll('input[id^="new-nickname-input-"]').forEach(input => {
        currentNicknameInputs.set(input.id, input.value);
      });

      tbody.innerHTML = ''; // Clear and re-render the table structure
      vmDropdownHttp.innerHTML = '<option value="">Select VM</option>';
      vmDropdownPort.innerHTML = '<option value="">Select VM</option>';

      for (const session of sessions) {
        if (session.vmIP) { // Only add VMs with assigned IPs
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>
              <span id="display-nickname-${session.sessionId}">${session.nickname || session.sessionId}</span><br>
              <input type="text" id="new-nickname-input-${session.sessionId}" placeholder="New Nickname" onkeydown="if(event.keyCode===13) setNickname('${session.sessionId}')">
              <button onclick="setNickname('${session.sessionId}')">Set</button>
            </td>
            <td>${session.clientIP}</td>
            <td>${session.vmIP}</td>
            <td>${session.vmMAC}</td>
            <td>${session.bytesSent}</td>
            <td>${session.bytesReceived}</td>
          `;
          tbody.appendChild(row);

          // Restore input value if it was being typed in
          const inputId = `new-nickname-input-${session.sessionId}`;
          if (currentNicknameInputs.has(inputId)) {
            document.getElementById(inputId).value = currentNicknameInputs.get(inputId);
          }

          const optionHttp = document.createElement('option');
          optionHttp.value = session.vmIP;
          optionHttp.textContent = `${session.nickname || session.vmIP}`;
          vmDropdownHttp.appendChild(optionHttp);

          const optionPort = document.createElement('option');
          optionPort.value = session.vmIP;
          optionPort.textContent = `${session.nickname || session.vmIP}`;
          vmDropdownPort.appendChild(optionPort);
        }
      }
      vmDropdownHttp.value = selectedVmHttp;
      vmDropdownPort.value = selectedVmPort;
    }
    fetchSessions();
    setInterval(fetchSessions, 5000);

    const typeRadios = document.querySelectorAll('input[name="proxy_type"]');
    const httpFields = document.getElementById('http-fields');
    const portFields = document.getElementById('port-fields');

    typeRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        if (document.querySelector('input[name="proxy_type"]:checked').value === 'port') {
          httpFields.style.display = 'none';
          portFields.style.display = 'block';
        } else {
          httpFields.style.display = 'block';
          portFields.style.display = 'none';
        }
      });
    });

    document.getElementById('add-rule-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const proxyType = document.querySelector('input[name="proxy_type"]:checked').value;
      let rule;

      if (proxyType === 'port') {
        const protocols = Array.from(document.querySelectorAll('input[name="protocol"]:checked')).map(cb => cb.value);
        if (protocols.length === 0) {
          alert('Please select at least one protocol (TCP or UDP).');
          return;
        }
        rule = {
          type: 'port',
          protocols: protocols, // e.g., ['tcp'], ['udp'], or ['tcp', 'udp']
          vm: document.getElementById('vm-port').value,
          port: parseInt(document.getElementById('port-port').value),
          host_port: parseInt(document.getElementById('host_port').value),
        };
      } else { // http
        rule = {
          type: 'http',
          vm: document.getElementById('vm').value,
          port: parseInt(document.getElementById('port').value),
          vhost: document.getElementById('vhost').value,
          path: document.getElementById('path').value,
          targetPath: document.getElementById('targetPath').value,
        };
      }

      await fetch('/api/rules', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(rule),
      });
      loadRules();
    });

    function showToaster(message, isError = false) {
      const toaster = document.getElementById('toaster-notification');
      toaster.textContent = message;
      toaster.style.backgroundColor = isError ? '#d9534f' : '#5cb85c'; // Red for error, green for success
      toaster.classList.add('show');
      setTimeout(() => {
        toaster.classList.remove('show');
      }, 3000);
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showToaster('Copied to clipboard!');
      }, (err) => {
        showToaster('Failed to copy: ' + err, true);
      });
    }

    async function loadRules() {
      const response = await fetch('/api/rules');
      const rules = await response.json();
      const tbody = document.querySelector('#rules tbody');
      tbody.innerHTML = '';
      for (const rule of rules) {
        const row = document.createElement('tr');
        let vhost, path, targetPath, testInfo, typeDisplay;

        if (rule.type === 'port') {
          typeDisplay = 'Port Forward';
          vhost = rule.host_port;
          path = rule.protocols.join(', ').toUpperCase();
          targetPath = '';
          const tcpCommand = `telnet localhost ${rule.host_port}`;
          const udpCommand = `echo "test" | nc -u -w1 localhost ${rule.host_port}`;
          let commands = [];
          if (rule.protocols.includes('tcp')) {
            commands.push(`<code>${tcpCommand}</code> <button onclick="copyToClipboard('${tcpCommand}')">Copy TCP</button>`);
          }
          if (rule.protocols.includes('udp')) {
            commands.push(`<code>${udpCommand}</code> <button onclick="copyToClipboard('${udpCommand}')">Copy UDP</button>`);
          }
          testInfo = commands.join('<br>');
        } else { // http
          typeDisplay = 'HTTP';
          vhost = rule.vhost || '';
          path = rule.path || '';
          targetPath = rule.targetPath || '';
          const proxyUrl = `http://localhost:8080${path}`;
          const link = rule.vhost ? `http://${rule.vhost}:8080${path}` : proxyUrl;
          const curlCommand = rule.vhost ? `curl -H "Host: ${rule.vhost}" ${proxyUrl}` : `curl ${proxyUrl}`;
          testInfo = `<a href="${link}" target="_blank">${link}</a><br><code>${curlCommand}</code> <button onclick="copyToClipboard('${curlCommand}')">Copy</button>`;
        }

        row.innerHTML = `
          <td>${typeDisplay}</td>
          <td>${vhost}</td>
          <td>${path}</td>
          <td>${rule.vm}:${rule.port}</td>
          <td>${targetPath}</td>
          <td>${testInfo}</td>
          <td><button onclick="deleteRule('${rule.id}')">Delete</button></td>
        `;
        tbody.appendChild(row);
      }
    }

    async function deleteRule(id) {
      await fetch(`/api/rules/${id}`, {method: 'DELETE'});
      loadRules();
    }

    async function setNickname(sessionId) {
      const newNicknameInput = document.getElementById(`new-nickname-input-${sessionId}`);
      const nickname = newNicknameInput.value;
      if (nickname) { // Only send if nickname is not empty
        await fetch(`/api/sessions/${sessionId}/nickname`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({nickname}),
        });
        newNicknameInput.value = ''; // Clear the input field
        fetchSessions(); // Refresh sessions to show updated nickname
      }
    }

    async function addSshPortForward() {
      document.querySelector('input[name="proxy_type"][value="port"]').checked = true;
      document.getElementById('http-fields').style.display = 'none';
      document.getElementById('port-fields').style.display = 'block';

      document.getElementById('host_port').value = '2222';
      document.getElementById('port-port').value = '22';
      document.getElementById('vm-port').value = document.getElementById('vm-port').options[1] ? document.getElementById('vm-port').options[1].value : ''; // Select first available VM

      document.querySelector('input[name="protocol"][value="tcp"]').checked = true;
      document.querySelector('input[name="protocol"][value="udp"]').checked = true;

      document.getElementById('add-rule-form').dispatchEvent(new Event('submit'));
    }

    async function addHttpPortForward() {
      document.querySelector('input[name="proxy_type"][value="port"]').checked = true;
      document.getElementById('http-fields').style.display = 'none';
      document.getElementById('port-fields').style.display = 'block';

      document.getElementById('host_port').value = '8888';
      document.getElementById('port-port').value = '80';
      document.getElementById('vm-port').value = document.getElementById('vm-port').options[1] ? document.getElementById('vm-port').options[1].value : ''; // Select first available VM

      document.querySelector('input[name="protocol"][value="tcp"]').checked = true;
      document.querySelector('input[name="protocol"][value="udp"]').checked = false; // Only TCP for HTTP

      document.getElementById('add-rule-form').dispatchEvent(new Event('submit'));
    }

    loadRules();
  </script>
</body>

</html>
