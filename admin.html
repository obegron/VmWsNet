<!DOCTYPE html>
<html>
<head>
  <title>JSLinux Relay Admin</title>
  <style>
    body { font-family: sans-serif; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
    form { margin-bottom: 20px; }
    .form-group { margin-bottom: 10px; display: flex; flex-direction: column; }
    .form-group label { margin-bottom: 5px; }
    .form-group input[type="text"], .form-group select { width: 200px; }
    .optional-text { font-size: 0.8em; color: #666; margin-top: 2px; }
    .toaster-notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      z-index: 1000;
    }
    .toaster-notification.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <h1>JSLinux Relay Admin</h1>
  <h2>Connected Clients</h2>
  <table id="sessions">
    <thead>
      <tr>
        <th>Session ID</th>
        <th>Client IP</th>
        <th>VM IP</th>
        <th>VM MAC</th>
        <th>Bytes Sent</th>
        <th>Bytes Received</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>

  <h2>Reverse Proxy Rules</h2>
  <form id="add-rule-form">
      <div>
        <label><input type="radio" name="type" value="http" checked> HTTP</label>
        <label><input type="radio" name="type" value="tcp"> TCP</label>
      </div>
      <div id="http-fields">
        <div class="form-group">
          <label for="vm">VM:</label>
          <select id="vm"></select>
        </div>
        <div class="form-group">
          <label for="port">VM Port:</label>
          <input type="text" id="port" placeholder="e.g., 80">
        </div>
        <div class="form-group">
          <label for="path">Path:</label>
          <input type="text" id="path" placeholder="e.g., /">
        </div>
        <div class="form-group">
          <label for="targetPath">Target Path:</label>
          <input type="text" id="targetPath" placeholder="e.g., /app">
          <span class="optional-text">optional</span>
        </div>
        <div class="form-group">
          <label for="vhost">VHost:</label>
          <input type="text" id="vhost" placeholder="e.g., domain.com">
          <span class="optional-text">optional</span>
        </div>
      </div>
      <div id="tcp-fields" style="display: none;">
        <div class="form-group">
          <label for="host_port">Host Port:</label>
          <input type="text" id="host_port" placeholder="e.g., 4445">
        </div>
        <div class="form-group">
          <label for="vm">VM:</label>
          <select id="vm-tcp"></select>
        </div>
        <div class="form-group">
          <label for="port">VM Port:
          <input type="text" id="port-tcp" placeholder="e.g., 80">
        </div>
      </div>
      <button type="submit">Add Rule</button>
    </form>
  <table id="rules">
    <thead>
      <tr>
        <th>Type</th>
        <th>VHost</th>
        <th>Path</th>
        <th>Destination</th>
        <th>Target Path</th>
        <th>Test</th>
        <th>Action&nbsp;</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>

  <div id="toaster-notification" class="toaster-notification"></div>

  <script>
    async function fetchSessions() {
      const response = await fetch('/api/sessions');
      const sessions = await response.json();
      const tbody = document.querySelector('#sessions tbody');
      const vmDropdownHttp = document.getElementById('vm');
      const vmDropdownTcp = document.getElementById('vm-tcp');
      const selectedVmHttp = vmDropdownHttp.value;
      const selectedVmTcp = vmDropdownTcp.value;

      // Store current nickname input values to restore later
      const currentNicknameInputs = new Map();
      tbody.querySelectorAll('input[id^="new-nickname-input-"]').forEach(input => {
        currentNicknameInputs.set(input.id, input.value);
      });

      tbody.innerHTML = ''; // Clear and re-render the table structure
      vmDropdownHttp.innerHTML = '<option value="">Select VM</option>';
      vmDropdownTcp.innerHTML = '<option value="">Select VM</option>';

      for (const session of sessions) {
        if (session.vmIP) { // Only add VMs with assigned IPs
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>
              <span id="display-nickname-${session.sessionId}">${session.nickname || session.sessionId}</span><br>
              <input type="text" id="new-nickname-input-${session.sessionId}" placeholder="New Nickname" onkeydown="if(event.keyCode===13) setNickname('${session.sessionId}')">
              <button onclick="setNickname('${session.sessionId}')">Set</button>
            </td>
            <td>${session.clientIP}</td>
            <td>${session.vmIP}</td>
            <td>${session.vmMAC}</td>
            <td>${session.bytesSent}</td>
            <td>${session.bytesReceived}</td>
          `;
          tbody.appendChild(row);

          // Restore input value if it was being typed in
          const inputId = `new-nickname-input-${session.sessionId}`;
          if (currentNicknameInputs.has(inputId)) {
            document.getElementById(inputId).value = currentNicknameInputs.get(inputId);
          }

          const optionHttp = document.createElement('option');
          optionHttp.value = session.vmIP;
          optionHttp.textContent = `${session.nickname || session.vmIP}`;
          vmDropdownHttp.appendChild(optionHttp);

          const optionTcp = document.createElement('option');
          optionTcp.value = session.vmIP;
          optionTcp.textContent = `${session.nickname || session.vmIP}`;
          vmDropdownTcp.appendChild(optionTcp);
        }
      }
      vmDropdownHttp.value = selectedVmHttp;
      vmDropdownTcp.value = selectedVmTcp;
    }
    fetchSessions();
    setInterval(fetchSessions, 5000);

      const typeRadios = document.querySelectorAll('input[name="type"]');
      const httpFields = document.getElementById('http-fields');
      const tcpFields = document.getElementById('tcp-fields');

      typeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          if (document.querySelector('input[name="type"]:checked').value === 'tcp') {
            httpFields.style.display = 'none';
            tcpFields.style.display = 'block';
          } else {
            httpFields.style.display = 'block';
            tcpFields.style.display = 'none';
          }
        });
      });

      document.getElementById('add-rule-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const type = document.querySelector('input[name="type"]:checked').value;
        let rule;

        if (type === 'tcp') {
          rule = {
            type,
            vm: document.getElementById('vm-tcp').value,
            port: parseInt(document.getElementById('port-tcp').value),
            host_port: parseInt(document.getElementById('host_port').value),
          };
        } else { // http
          rule = {
            type,
            vm: document.getElementById('vm').value,
            port: parseInt(document.getElementById('port').value),
            vhost: document.getElementById('vhost').value,
            path: document.getElementById('path').value,
            targetPath: document.getElementById('targetPath').value,
          };
        }

        await fetch('/api/rules', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(rule),
        });
        loadRules();
      });

      function showToaster(message, isError = false) {
        const toaster = document.getElementById('toaster-notification');
        toaster.textContent = message;
        toaster.style.backgroundColor = isError ? '#d9534f' : '#5cb85c'; // Red for error, green for success
        toaster.classList.add('show');
        setTimeout(() => {
          toaster.classList.remove('show');
        }, 3000);
      }

      function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
          showToaster('Copied to clipboard!');
        }, (err) => {
          showToaster('Failed to copy: ' + err, true);
        });
      }

      async function loadRules() {
      const response = await fetch('/api/rules');
      const rules = await response.json();
      const tbody = document.querySelector('#rules tbody');
      tbody.innerHTML = '';
      for (const rule of rules) {
        const row = document.createElement('tr');
        let vhost, path, targetPath, testInfo;
        if (rule.type === 'tcp') {
          vhost = rule.host_port;
          path = '';
          targetPath = '';
          const command = `telnet localhost ${rule.host_port}`;
          testInfo = `<code>${command}</code> <button onclick="copyToClipboard('${command}')">Copy</button>`;
        } else { // http
          vhost = rule.vhost || '';
          path = rule.path || '';
          targetPath = rule.targetPath || '';
          const proxyUrl = `http://localhost:8080${path}`;
          const link = rule.vhost ? `http://${rule.vhost}:8080${path}` : proxyUrl;
          const curlCommand = rule.vhost ? `curl -H "Host: ${rule.vhost}" ${proxyUrl}` : `curl ${proxyUrl}`;
          testInfo = `<a href="${link}" target="_blank">${link}</a><br><code>${curlCommand}</code> <button onclick="copyToClipboard('${curlCommand}')">Copy</button>`;
        }

        row.innerHTML = `
          <td>${rule.type}</td>
          <td>${vhost}</td>
          <td>${path}</td>
          <td>${rule.vm}:${rule.port}</td>
          <td>${targetPath}</td>
          <td>${testInfo}</td>
          <td><button onclick="deleteRule('${rule.id}')">Delete</button></td>
        `;
        tbody.appendChild(row);
      }
    }

    async function deleteRule(id) {
      await fetch(`/api/rules/${id}`, { method: 'DELETE' });
      loadRules();
    }

    async function setNickname(sessionId) {
      const newNicknameInput = document.getElementById(`new-nickname-input-${sessionId}`);
      const nickname = newNicknameInput.value;
      if (nickname) { // Only send if nickname is not empty
        await fetch(`/api/sessions/${sessionId}/nickname`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ nickname }),
        });
        newNicknameInput.value = ''; // Clear the input field
        fetchSessions(); // Refresh sessions to show updated nickname
      }
    }

    loadRules();
  </script>
</body>
</html>